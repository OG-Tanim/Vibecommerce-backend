import { Request, Response, NextFunction } from 'express'
import { ProductService } from './product.service'
import { AuthenticatedRequest } from '@middleware/auth'
import { CreateProductSchema } from './product.validation'


export const createProduct = async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    // No try-catch block, errors will be passed to the centralized error handler by the next function

    const userId = req.user!.id
    const validatedData = CreateProductSchema.parse(req.body)
    const { title, description, price, category, discountPrice, discountValidTill } = validatedData
    
    const imageFiles = req.files as Express.Multer.File[]                      //taking the files to extract public ids from 'req.files' for images 
    const imageIds = imageFiles.map(file => file.filename)                     //usually file name generated by cloudinary is Public ID
    const images = (req.files as Express.Multer.File[]).map(file => file.path) //taking the file paths (urls) only
    
    const videoFile = req.file as Express.Multer.File | undefined              //taking the files to extract public id from 'req.file' for videos
    const videoId = videoFile?.filename
    const video = (req.file as Express.Multer.File)?.path
    

    const product = await ProductService.create(userId, {
        title, 
        description, 
        price, 
        category,
        images,
        imageIds, 
        video,
        videoId,
        discountPrice,
        discountValidTill
    })

    res.status(200).json(product)
}

export const getAllProducts = async (_req: Request, res: Response) => {
    const products = await ProductService.getAll()
    res.json(products)
}

export const getProductById = async (req:Request, res: Response) => {
    const product = await ProductService.getById(req.params.id);
    if (!product) {
        res.status(404).json({ message: 'Product not found' });
        return                                                              //ts route handler must retrun either void or promise<void>
    }
    res.json(product);
  }

export const updateProduct = async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    const userId = req.user!.id
    const validatedData = CreateProductSchema.parse(req.body)
    const { title, description, price, category, discountPrice, discountValidTill } = validatedData

    const imageFiles = req.files as Express.Multer.File[] | undefined
    const imageIds = imageFiles?.map(file => file.filename)
    const images = imageFiles?.map(file => file.path)

    const videoFile = req.file as Express.Multer.File | undefined
    const videoId = videoFile?.filename
    const video = videoFile?.path 

    const updated = await ProductService.update(req.params.id, req.user!.id, {
        title, 
        description,
        price, 
        category, 
        ...(images && { images }),                                        //if images exist, add { images } to the object as they are defined as optional fields
        ...(imageIds && { imageIds}),
        ...(video && { video }),
        ...(videoId && { videoId }),
        discountPrice,
        discountValidTill
    })
    res.json(updated)
} 

export const deleteProduct = async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    // No try-catch block, errors will be passed to the centralized error handler by the next function

    const deleted = await ProductService.delete(req.params.id, req.user!.id)
    res.json('Product deleted')

}

export const searchProduct = async (req: Request, res: Response, next: NextFunction) => {
    // No try-catch block, errors will be passed to the centralized error handler by the next function

    const { name, category, minPrice, maxPrice} = req.query

    const products = await ProductService.searchProducts({
        name: name as string,
        category: category as string,
        minPrice: minPrice ? parseFloat(minPrice as string) : undefined, //if min price exists parse float to number or not needed
        maxPrice: maxPrice ? parseFloat(maxPrice as string) : undefined
    })

    res.json(products)
}